From 3160a2cf08ac26f25c388ad15047d7595b61c4ca Mon Sep 17 00:00:00 2001
From: Muni Sakkuru <muni.sakkuru@gmail.com>
Date: Tue, 24 Mar 2020 17:15:28 -0700
Subject: [PATCH 1/1] Alexa Auto changes for v1.17 AVS Device SDK

For internal reference: c50b32c200342fc485c1da11efbfcbbf796f4463
---
 ACL/src/AVSConnectionManager.cpp              |   4 +-
 ADSL/include/ADSL/DirectiveProcessor.h        |  15 +-
 ADSL/include/ADSL/DirectiveSequencer.h        |   4 +
 ADSL/src/DirectiveProcessor.cpp               |  25 +-
 ADSL/src/DirectiveSequencer.cpp               |   8 +
 ADSL/test/ADSL/MockDirectiveSequencer.h       |   4 +
 AFML/include/AFML/FocusManager.h              |   2 +
 AFML/src/FocusManager.cpp                     |  27 +++
 .../AVS/AVSDiscoveryEndpointAttributes.h      |   4 +
 .../include/AVSCommon/AVS/EndpointResources.h | 188 +++++++++++++++
 AVSCommon/AVS/src/EndpointResources.cpp       | 221 ++++++++++++++++++
 AVSCommon/CMakeLists.txt                      |   3 +
 .../CallStateObserverInterface.h              |  17 +-
 .../DirectiveSequencerInterface.h             |   4 +
 .../Endpoints/EndpointBuilderInterface.h      |  19 +-
 .../SDKInterfaces/FocusManagerInterface.h     |  11 +
 .../SDKInterfaces/MockDirectiveSequencer.h    |   4 +
 .../SDKInterfaces/MockFocusManager.h          |   1 +
 .../LibcurlUtils/CurlEasyHandleWrapper.h      |  24 +-
 .../AVSCommon/Utils/LibcurlUtils/HttpDelete.h |  83 +++++++
 .../Utils/LibcurlUtils/HttpDeleteInterface.h  |  56 +++++
 .../AVSCommon/Utils/LibcurlUtils/HttpGet.h    |  83 +++++++
 .../Utils/LibcurlUtils/HttpGetInterface.h     |  56 +++++
 .../LibcurlUtils/CurlEasyHandleWrapper.cpp    |  23 +-
 .../Utils/src/LibcurlUtils/HttpDelete.cpp     | 129 ++++++++++
 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp  | 129 ++++++++++
 .../DefaultClient/src/DefaultClient.cpp       |   2 +
 .../src/PostConnectCapabilitiesPublisher.cpp  |   4 +-
 .../src/Utils/DiscoveryUtils.cpp              |  32 ++-
 .../include/Alerts/AlertObserverInterface.h   |  23 ++
 .../include/Alerts/AlertsCapabilityAgent.h    |  41 ++++
 .../Alerts/src/AlertsCapabilityAgent.cpp      |  54 +++++
 .../include/AudioPlayer/AudioPlayer.h         |   7 +
 .../AudioPlayer/src/AudioPlayer.cpp           |  24 +-
 .../AudioPlayer/src/CMakeLists.txt            |   7 +-
 .../AudioPlayer/test/AudioPlayerTest.cpp      |  77 +++++-
 .../DoNotDisturbCapabilityAgent.h             |  46 ++--
 .../MRM/include/MRM/MRMCapabilityAgent.h      |   6 +-
 .../MRM/src/MRMCapabilityAgent.cpp            |   6 +-
 .../PlaybackController/PlaybackController.h   |  14 +-
 .../src/PlaybackController.cpp                |  33 ++-
 .../src/SpeechSynthesizer.cpp                 |  27 ++-
 .../test/SpeechSynthesizerTest.cpp            | 137 +++++++++++
 .../TemplateRuntime/src/TemplateRuntime.cpp   |   6 +-
 .../Implementation/src/SystemClockDelay.cpp   |   2 +-
 CertifiedSender/src/CertifiedSender.cpp       |   5 +-
 .../Endpoints/EndpointAttributeValidation.h   |   8 +
 Endpoints/include/Endpoints/EndpointBuilder.h |   5 +
 Endpoints/src/EndpointAttributeValidation.cpp |   4 +
 Endpoints/src/EndpointBuilder.cpp             |  31 ++-
 .../test/AudioPlayerIntegrationTest.cpp       |  19 ++
 .../include/SampleApp/InteractionManager.h    |   2 +-
 SampleApp/src/InteractionManager.cpp          |   2 +-
 53 files changed, 1676 insertions(+), 92 deletions(-)
 create mode 100644 AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
 create mode 100644 AVSCommon/AVS/src/EndpointResources.cpp
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
 create mode 100644 AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
 create mode 100644 AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp

diff --git a/ACL/src/AVSConnectionManager.cpp b/ACL/src/AVSConnectionManager.cpp
index c9d16f3..b2fe711 100644
--- a/ACL/src/AVSConnectionManager.cpp
+++ b/ACL/src/AVSConnectionManager.cpp
@@ -138,7 +138,9 @@ void AVSConnectionManager::reconnect() {
 }
 
 void AVSConnectionManager::sendMessage(std::shared_ptr<avsCommon::avs::MessageRequest> request) {
-    m_messageRouter->sendMessage(request);
+    if (m_messageRouter != nullptr) {
+        m_messageRouter->sendMessage(request);
+    }
 }
 
 bool AVSConnectionManager::isConnected() const {
diff --git a/ADSL/include/ADSL/DirectiveProcessor.h b/ADSL/include/ADSL/DirectiveProcessor.h
index 174aac6..424b698 100644
--- a/ADSL/include/ADSL/DirectiveProcessor.h
+++ b/ADSL/include/ADSL/DirectiveProcessor.h
@@ -81,7 +81,7 @@ public:
      * @param dialogRequestId The new value for the current @c dialogRequestId.
      */
     void setDialogRequestId(const std::string& dialogRequestId);
-
+   
     /**
      * Returns the @c dialogRequestId currently in use for Directive handling. This may be the empty string if
      * Directives have either experienced errors, or have been cancelled.
@@ -90,6 +90,10 @@ public:
      */
     std::string getDialogRequestId();
 
+    void setIsDialogRequestOnline(bool isOnline);
+
+    bool isDialogRequestOnline();
+
     /**
      * Queue an @c AVSDirective for handling by whatever @c DirectiveHandler was registered to handle it.
      *
@@ -192,6 +196,12 @@ private:
      */
     void processingLoop();
 
+    void setIsDialogRequestOnlineLocked(bool isOnline);
+
+    bool isDialogRequestOnlineLocked();
+
+    std::string getDialogRequestIdLocked();
+
     /**
      * Process (cancel) all the items in @c m_cancelingQueue.
      * @note This method must only be called by threads that have acquired @c m_mutex.
@@ -293,6 +303,9 @@ private:
     /// Whether or not the @c DirectiveProcessor is enabled.
     bool m_isEnabled;
 
+    /// Whether the current dialog request is from AVS (online) or AHE (offline)
+    bool m_isDialogRequestOnline;
+
     /// The current @c dialogRequestId
     std::string m_dialogRequestId;
 
diff --git a/ADSL/include/ADSL/DirectiveSequencer.h b/ADSL/include/ADSL/DirectiveSequencer.h
index d381118..77e0334 100644
--- a/ADSL/include/ADSL/DirectiveSequencer.h
+++ b/ADSL/include/ADSL/DirectiveSequencer.h
@@ -54,6 +54,10 @@ public:
 
     std::string getDialogRequestId() override;
 
+    void setIsDialogRequestOnline(bool isOnline) override;
+
+    bool isDialogRequestOnline() override;
+
     bool onDirective(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
 
     void disable() override;
diff --git a/ADSL/src/DirectiveProcessor.cpp b/ADSL/src/DirectiveProcessor.cpp
index fc5b484..85acfce 100644
--- a/ADSL/src/DirectiveProcessor.cpp
+++ b/ADSL/src/DirectiveProcessor.cpp
@@ -47,7 +47,8 @@ std::unordered_map<DirectiveProcessor::ProcessorHandle, DirectiveProcessor*> Dir
 DirectiveProcessor::DirectiveProcessor(DirectiveRouter* directiveRouter) :
         m_directiveRouter{directiveRouter},
         m_isShuttingDown{false},
-        m_isEnabled{true} {
+        m_isEnabled{true},
+        m_isDialogRequestOnline{true} {
     std::lock_guard<std::mutex> lock(m_handleMapMutex);
     m_handle = ++m_nextProcessorHandle;
     m_handleMap[m_handle] = this;
@@ -68,6 +69,16 @@ std::string DirectiveProcessor::getDialogRequestId() {
     return m_dialogRequestId;
 }
 
+void DirectiveProcessor::setIsDialogRequestOnline(bool isOnline) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    setIsDialogRequestOnlineLocked(isOnline);
+}
+
+bool DirectiveProcessor::isDialogRequestOnline() {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    return isDialogRequestOnlineLocked();
+}
+
 bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
@@ -122,6 +133,18 @@ bool DirectiveProcessor::onDirective(std::shared_ptr<AVSDirective> directive) {
     return true;
 }
 
+std::string DirectiveProcessor::getDialogRequestIdLocked() {
+    return m_dialogRequestId;
+}
+
+void DirectiveProcessor::setIsDialogRequestOnlineLocked(bool isOnline) {
+    m_isDialogRequestOnline = isOnline;
+}
+
+bool DirectiveProcessor::isDialogRequestOnlineLocked() {
+    return m_isDialogRequestOnline;
+}
+
 void DirectiveProcessor::shutdown() {
     {
         std::lock_guard<std::mutex> lock(m_handleMapMutex);
diff --git a/ADSL/src/DirectiveSequencer.cpp b/ADSL/src/DirectiveSequencer.cpp
index d8c361c..2240f09 100644
--- a/ADSL/src/DirectiveSequencer.cpp
+++ b/ADSL/src/DirectiveSequencer.cpp
@@ -66,6 +66,14 @@ std::string DirectiveSequencer::getDialogRequestId() {
     return m_directiveProcessor->getDialogRequestId();
 }
 
+bool DirectiveSequencer::isDialogRequestOnline() {
+    return m_directiveProcessor->isDialogRequestOnline();
+}
+
+void DirectiveSequencer::setIsDialogRequestOnline(bool isOnline) {
+    m_directiveProcessor->setIsDialogRequestOnline(isOnline);
+}
+
 bool DirectiveSequencer::onDirective(std::shared_ptr<AVSDirective> directive) {
     if (!directive) {
         ACSDK_ERROR(LX("onDirectiveFailed").d("action", "ignored").d("reason", "nullptrDirective"));
diff --git a/ADSL/test/ADSL/MockDirectiveSequencer.h b/ADSL/test/ADSL/MockDirectiveSequencer.h
index 3cff6cc..0562444 100644
--- a/ADSL/test/ADSL/MockDirectiveSequencer.h
+++ b/ADSL/test/ADSL/MockDirectiveSequencer.h
@@ -51,6 +51,10 @@ public:
         return m_dialogRequestId;
     };
 
+    MOCK_METHOD0(isDialogRequestOnline, bool());
+    
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
 
     MOCK_METHOD0(disable, void());
diff --git a/AFML/include/AFML/FocusManager.h b/AFML/include/AFML/FocusManager.h
index 4d0cdbf..9f01309 100644
--- a/AFML/include/AFML/FocusManager.h
+++ b/AFML/include/AFML/FocusManager.h
@@ -107,6 +107,8 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) override;
 
+    bool releaseChannel(const std::string& channelName) override;
+
     void stopForegroundActivity() override;
 
     void stopAllActivities() override;
diff --git a/AFML/src/FocusManager.cpp b/AFML/src/FocusManager.cpp
index 4b42532..7bdec45 100644
--- a/AFML/src/FocusManager.cpp
+++ b/AFML/src/FocusManager.cpp
@@ -91,6 +91,33 @@ std::future<bool> FocusManager::releaseChannel(
     return returnValue;
 }
 
+bool FocusManager::releaseChannel(const std::string& channelName) {
+    ACSDK_DEBUG1(LX("releaseChannel").d("channelName", channelName));
+
+    std::shared_ptr<Channel> channelToRelease = getChannel(channelName);
+    if (!channelToRelease) {
+        ACSDK_ERROR(LX("releaseChannelFailed").d("reason", "channelNotFound").d("channelName", channelName));
+        return false;
+    }
+
+    auto task = [this, channelToRelease]() {
+        // Lock here to update internal state which stopForegroundActivity may concurrently access.
+        std::unique_lock<std::mutex> lock(m_mutex);
+        bool wasForegrounded = isChannelForegroundedLocked(channelToRelease);
+        m_activeChannels.erase(channelToRelease);
+        lock.unlock();
+
+        setChannelFocus(channelToRelease, FocusState::NONE);
+        if (wasForegrounded) {
+            foregroundHighestPriorityActiveChannel();
+        }
+        notifyActivityTracker();
+    };
+
+    m_executor.submit(task);
+    return true;
+}
+
 void FocusManager::stopForegroundActivity() {
     // We lock these variables so that we can correctly capture the currently foregrounded channel and activity.
     std::unique_lock<std::mutex> lock(m_mutex);
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
index 269344e..81fff4b 100644
--- a/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/AVSDiscoveryEndpointAttributes.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include <AVSCommon/AVS/EndpointResources.h>
 #include <AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h>
 #include <AVSCommon/Utils/Optional.h>
 
@@ -111,6 +112,9 @@ struct AVSDiscoveryEndpointAttributes {
     /// A non-empty string identifying the endpoint manufacturer name.
     std::string manufacturerName;
 
+    /// An EndpointResources object containing friendly names, manufacturer name and description.
+    EndpointResources endpointResources;
+
     /// The display categories the device belongs to. This field should contain at least one category. See categories
     /// in this document: https://developer.amazon.com/docs/device-apis/alexa-discovery.html#display-categories
     /// @note: This value should only include ALEXA_VOICE_ENABLED for the default endpoint.
diff --git a/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
new file mode 100644
index 0000000..1bb0b5b
--- /dev/null
+++ b/AVSCommon/AVS/include/AVSCommon/AVS/EndpointResources.h
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
+
+#include <string>
+#include <vector>
+
+#include <AVSCommon/SDKInterfaces/LocaleAssetsManagerInterface.h>
+#include <AVSCommon/Utils/Optional.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+class EndpointResources {
+public:
+    /**
+     * The constructor.
+     */
+    EndpointResources();
+
+    /**
+     * Function to add friendly name using asset id.
+     * 
+     * @param assetId The asset id of the friendly name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add friendly name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the friendly names
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the friendly name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the friendly name. 
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addFriendlyNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add manufacturer name using asset id.
+     *
+     * @param assetId The asset id of the manufacturer name using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add manufacturer name using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the manufacturer name
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the manufacturer name. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the manufacturer name.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addManufacturerNameWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to add description using asset id.
+     *
+     * @param assetId The asset id of the description using @c string.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithAssetId(const std::string& assetId);
+
+    /**
+     * Function to add description using text value and its locale.
+     *
+     * @note When using this method it is recommended to provide the description
+     * in all the Alexa supported languages. See the class-level link to find the currently
+     * supported languages.
+     *
+     * @note Providing an unsupported locale will result in Discovery failure.
+     *
+     * @param text The text of the description. This value can contain up to 128 valid characters.
+     * @param locale The non-empty locale of the description.
+     * @return This instance to facilitate setting more information to this EndpointResources.
+     */
+    EndpointResources& addDescriptionWithText(
+            const std::string& text,
+            const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale);
+
+    /**
+     * Function to check if the @c EndpointResources is valid.
+     *
+     * @return Return @c true if valid, otherwise @c false.
+     */
+     bool isValid() const;
+
+    /**
+     * Builds a new EndpointResources with the configured properties.
+     *
+     * Build will fail if any attribute is invalid or if a mandatory attribute is missing.
+     *
+     * @return A json string representing the EndpointResources; otherwise, an empty string.
+     */
+     std::string build() const;
+
+private:
+    /**
+     * Struct defining a Label, used to describe a resource.
+     * @see https://developer.amazon.com/docs/device-apis/resources-and-assets.html#capability-resources
+     */
+    struct Label {
+        /// The enum representing the Label type.
+        enum class LabelType {
+            /// Asset type.
+            ASSET,
+
+            /// Text type.
+            TEXT
+        };
+
+        /// The type of the Label. 
+        LabelType type;
+
+        /// The value to contain the text or the asset id of the friendly name, manufacturer name or description.
+        std::string value;
+
+        /// The locale of the text, and empty object for asset.
+        avsCommon::utils::Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale> locale;
+
+        /**
+         *  @name Comparison operator.
+         *
+         *  Compare the current Label against a second object.
+         *  Defined for std::find.
+         *
+         *  @param rhs The object to compare against this.
+         *  @return @c true if the comparison holds; @c false otherwise.
+         */
+        /// @{
+        bool operator==(const Label& rhs) const;
+        /// @}
+
+        /**
+         * Helper function to convert a Label to a json string.
+         *
+         * @return A json string of Label.
+         */
+        std::string toJson() const;
+    };
+
+    /// Flag to indicate if there was any error noted.
+    bool m_isValid = false;
+
+    /// Vector holding @c Label for the friendly names.
+    std::vector<Label> m_friendlyNames;
+
+    /// @c Label that holds the manufacturer name.
+    Label m_manufacturerName;
+
+    /// @c Label that holds the description.
+    Label m_description;
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif //ALEXA_CLIENT_SDK_AVSCOMMON_AVS_INCLUDE_AVSCOMMON_AVS_ENDPOINTRESOURCES_H_
diff --git a/AVSCommon/AVS/src/EndpointResources.cpp b/AVSCommon/AVS/src/EndpointResources.cpp
new file mode 100644
index 0000000..620d704
--- /dev/null
+++ b/AVSCommon/AVS/src/EndpointResources.cpp
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <algorithm>
+
+#include <AVSCommon/AVS/EndpointResources.h>
+#include <AVSCommon/Utils/JSON/JSONGenerator.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace avs {
+
+using namespace avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("EndpointResources");
+
+/**
+* Create a LogEntry using this file's TAG and the specified event string.
+*
+* @param The event string for this @c LogEntry.
+*/
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/// Maximum length of the friendly name
+static constexpr size_t MAX_FRIENDLY_NAME_LENGTH = 128;
+/// Maximum length of the manufacturer name
+static constexpr size_t MAX_MANUFACTURER_NAME_LENGTH = 128;
+/// Maximum length of the description
+static constexpr size_t MAX_DESCRIPTION_LENGTH = 128;
+
+EndpointResources::EndpointResources() : m_isValid{true} {
+}
+
+bool EndpointResources::Label::operator==(const EndpointResources::Label& rhs) const {
+    return value == rhs.value && locale.valueOr("") == rhs.locale.valueOr("");
+}
+
+EndpointResources& EndpointResources::addFriendlyNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+
+    if (std::find(
+            m_friendlyNames.begin(),
+            m_friendlyNames.end(),
+            EndpointResources::Label(
+                    {Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()})) != m_friendlyNames.end()) {
+        ACSDK_ERROR(LX("addFriendlyNameWithAssetIdFailed").d("reason", "duplicateAssetId").sensitive("assetId", assetId));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_friendlyNames.push_back({Label::LabelType::ASSET, assetId, utils::Optional<sdkInterfaces::LocaleAssetsManagerInterface::Locale>()});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addFriendlyNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+        if (text.length() == 0 || text.length() > MAX_FRIENDLY_NAME_LENGTH) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidText"));
+            m_isValid = false;
+        }
+        if (locale.empty()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed").d("reason", "invalidLocale"));
+            m_isValid = false;
+        }
+        if (std::find(
+                m_friendlyNames.begin(),
+                m_friendlyNames.end(),
+                Label({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)})) !=
+                m_friendlyNames.end()) {
+            ACSDK_ERROR(LX("addFriendlyNameWithTextFailed")
+                                .d("reason", "duplicateText")
+                                .sensitive("text", text)
+                                .sensitive("locale", locale));
+            m_isValid = false;
+        }
+
+        m_friendlyNames.push_back({Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)});
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+
+    return *this;
+};
+
+EndpointResources& EndpointResources::addManufacturerNameWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_MANUFACTURER_NAME_LENGTH) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addManufacturerNameWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_manufacturerName.value.length() != 0){
+        ACSDK_ERROR(LX("addManufacturerNameWithAssetIdFailed").d("reason", "manufacturerNameAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_manufacturerName = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+
+EndpointResources& EndpointResources::addDescriptionWithAssetId(const std::string& assetId) {
+    if (assetId.length() == 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "invalidAssetId"));
+        m_isValid = false;
+        return *this;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::ASSET, assetId, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>()};
+    return *this;
+};
+
+EndpointResources& EndpointResources::addDescriptionWithText(
+        const std::string& text,
+        const avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale& locale) {
+
+    if (text.length() == 0 || text.length() > MAX_DESCRIPTION_LENGTH) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidText"));
+        m_isValid = false;
+    }
+    if (locale.empty()) {
+        ACSDK_ERROR(LX("addDescriptionWithTextFailed").d("reason", "invalidLocale"));
+        m_isValid = false;
+    }
+    if (m_description.value.length() != 0){
+        ACSDK_ERROR(LX("addDescriptionWithAssetIdFailed").d("reason", "descriptionAlreadyExists"));
+        m_isValid = false;
+        return *this;
+    }
+
+    m_description = {Label::LabelType::TEXT, text, Optional<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface::Locale>(locale)};
+    return *this;
+};
+
+bool EndpointResources::isValid() const {
+    return m_isValid && m_friendlyNames.size() > 0 && m_description.value.length() > 0
+                     && m_manufacturerName.value.length() > 0;
+};
+
+std::string EndpointResources::build() const {
+    if (!isValid()) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return "";
+    }
+    json::JsonGenerator jsonGenerator;
+    std::vector<std::string> friendlyNames;
+    for (auto &friendlyName : m_friendlyNames){
+        friendlyNames.push_back(friendlyName.toJson());
+    }
+    jsonGenerator.addMembersArray("friendlyNames", friendlyNames);
+    jsonGenerator.addRawJsonMember("manufacturerName", m_manufacturerName.toJson());
+    jsonGenerator.addRawJsonMember("description", m_description.toJson());
+    return jsonGenerator.toString();
+};
+
+std::string EndpointResources::Label::toJson() const {
+    json::JsonGenerator scopeGenerator;
+    if (type == Label::LabelType::TEXT) {
+        scopeGenerator.addMember("@type", "text");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("text", value);
+        scopeGenerator.addMember("locale", locale.value());
+    } else if (type == Label::LabelType::ASSET) {
+        scopeGenerator.addMember("@type", "asset");
+        scopeGenerator.startObject("value");
+        scopeGenerator.addMember("assetId", value);
+    } else{
+        return "{}";
+    }
+    return scopeGenerator.toString();
+};
+
+}  // namespace avs
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/CMakeLists.txt b/AVSCommon/CMakeLists.txt
index d10b8cc..db276d3 100644
--- a/AVSCommon/CMakeLists.txt
+++ b/AVSCommon/CMakeLists.txt
@@ -31,6 +31,7 @@ add_library(AVSCommon SHARED
     AVS/src/EventBuilder.cpp
     AVS/src/ExceptionEncounteredSender.cpp
     AVS/src/CapabilityResources.cpp
+    AVS/src/EndpointResources.cpp
     AVS/src/HandlerAndPolicy.cpp
     AVS/src/MessageRequest.cpp
     AVS/src/NamespaceAndName.cpp
@@ -54,6 +55,8 @@ add_library(AVSCommon SHARED
     Utils/src/LibcurlUtils/HTTPContentFetcherFactory.cpp
     Utils/src/LibcurlUtils/HttpPost.cpp
     Utils/src/LibcurlUtils/HttpPut.cpp
+    Utils/src/LibcurlUtils/HttpGet.cpp
+    Utils/src/LibcurlUtils/HttpDelete.cpp
     Utils/src/LibcurlUtils/HTTPResponse.cpp
     Utils/src/LibcurlUtils/LibCurlHttpContentFetcher.cpp
     Utils/src/LibcurlUtils/LibcurlHTTP2Connection.cpp
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
index fc8e7cd..118e5f1 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/CallStateObserverInterface.h
@@ -41,17 +41,30 @@ public:
         NONE
     };
 
+    /// Information about the call to display on screen-based devices when the observer is notified of a call state change.
+    struct CallDisplayInfo {
+        /// The contact name to be displayed.
+        std::string displayName;
+        /// Information about the endpoint of the contact (work/mobile/home etc.).
+        std::string endpointLabel;
+        /// Contains name of callee for whom incoming call is intended. This field is not populated for Alexa/Skype calls currently.
+        std::string inboundCalleeName;
+        /// Textual description of exact call provider type (e.g. "Alexa Call", "Skype Call" etc.).
+        std::string callProviderType;
+    };
+
     /**
      * Destructor
      */
     virtual ~CallStateObserverInterface() = default;
 
     /**
-     * Allows the observer to react to a change in call state.
+     * Allows the observer to react to a change in call state with display info for the call.
      *
      * @param state The new CallState.
+     * @param displayInfo Information to be used for display on screen-based devices.
      */
-    virtual void onCallStateChange(CallState state) = 0;
+    virtual void onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) = 0;
 };
 
 /**
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
index cd12ece..5e48299 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/DirectiveSequencerInterface.h
@@ -97,6 +97,10 @@ public:
      */
     virtual std::string getDialogRequestId() = 0;
 
+    virtual void setIsDialogRequestOnline(bool isOnline) = 0;
+
+    virtual bool isDialogRequestOnline() = 0;
+
     /**
      * Sequence the handling of an @c AVSDirective.  The actual handling is done by whichever @c DirectiveHandler
      * is associated with the most specific routing rule.
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
index 28beb5e..527cfab 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h
@@ -19,6 +19,7 @@
 #include <memory>
 #include <string>
 
+#include "AVSCommon/AVS/EndpointResources.h"
 #include "AVSCommon/SDKInterfaces/Endpoints/EndpointIdentifier.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerAttributes.h"
 #include "AVSCommon/SDKInterfaces/ModeController/ModeControllerInterface.h"
@@ -131,18 +132,32 @@ public:
      * @note This value can contain up to 128 characters.
      * @note The builder will fail if the manufacturer name param is invalid.
      *
-     * @param description The manufacturer name of the device representing the endpoint.
+     * @param manufacturerName The manufacturer name of the device representing the endpoint.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withManufacturerName(const std::string& manufacturerName) = 0;
 
+    /**
+     * Configures builder to use endpointResources representing the endpoint.
+     *
+     * @note EndpointResources contains friendlyNames, manufacturer name and description.
+     * @note Use either withFriendlyName, withDescription, withManufacturerName to build or withEndpointResources
+     * to build. 
+     * @note The builder will fail if the endpointResources param is invalid.
+     *
+     * @param endpointResources The endpointResources of the device representing the endpoint.
+     * @return This builder which can be used to nest configuration function calls.
+     */
+    virtual EndpointBuilderInterface& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) = 0;
+
     /**
      * Configures builder to use the following display categories.
      *
      * @note This will override any previous display categories configuration.
      * @note The builder will fail if the displayCategories param is invalid.
      *
-     * @param description The display category the device belongs to.
+     * @param displayCategories The display category the device belongs to.
      * @return This builder which can be used to nest configuration function calls.
      */
     virtual EndpointBuilderInterface& withDisplayCategory(const std::vector<std::string>& displayCategories) = 0;
diff --git a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
index fc550eb..b92aba5 100644
--- a/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
+++ b/AVSCommon/SDKInterfaces/include/AVSCommon/SDKInterfaces/FocusManagerInterface.h
@@ -114,6 +114,17 @@ public:
         const std::string& channelName,
         std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver) = 0;
 
+    /**
+     * This method will release the Channel without specifying the observer and notify the current observer of the 
+     * Channel to stop via ChannelObserverInterface##onFocusChanged(). If the Channel to release is the current 
+     * foreground focused Channel, it will also notify the next highest priority Channel via a 
+     * ChannelObserverInterface##onFocusChanged() callback that it has gained foreground focus.
+     *
+     * @param channelName The name of the Channel to release.
+     * @return Returns @c true if the Channel can be released and @c false otherwise.
+     */
+    virtual bool releaseChannel(const std::string& channelName) = 0;    
+
     /**
      * This method will request that the currently foregrounded Channel activity be stopped, if there is one. This will
      * be performed asynchronously, and so, if at the time of processing, the activity has stopped for any reason, then
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
index 263e025..680d6e1 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockDirectiveSequencer.h
@@ -37,6 +37,10 @@ public:
     inline std::string getDialogRequestId() {
         return m_dialogRequestId;
     };
+	
+	MOCK_METHOD0(isDialogRequestOnline, bool());
+    MOCK_METHOD1(setIsDialogRequestOnline, void(bool));
+	
     MOCK_METHOD1(onDirective, bool(std::shared_ptr<avsCommon::avs::AVSDirective> directive));
     MOCK_METHOD0(doShutdown, void());
     MOCK_METHOD0(disable, void());
diff --git a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
index c2404fe..507c613 100644
--- a/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
+++ b/AVSCommon/SDKInterfaces/test/AVSCommon/SDKInterfaces/MockFocusManager.h
@@ -39,6 +39,7 @@ public:
             const std::string& channelName,
             std::shared_ptr<avsCommon::sdkInterfaces::ChannelObserverInterface> channelObserver));
     MOCK_METHOD0(stopForegroundActivity, void());
+    MOCK_METHOD1(releaseChannel, bool(const std::string& channelName));
     MOCK_METHOD1(
         addObserver,
         void(const std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerObserverInterface>& observer));
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
index 72a7834..beb9cd7 100644
--- a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h
@@ -73,7 +73,9 @@ public:
         /// HTTP POST
         kPOST,
         /// HTTP PUT
-        kPUT
+        kPUT,
+        /// HTTP DELETE
+        kDELETE
     };
 
     /**
@@ -254,6 +256,23 @@ public:
      */
     CURLcode pause(int mask);
 
+    /**
+     * Static function to set the network interface for the curl.
+     *
+     * Inteface provided will be used in preference over the
+     * value in provided in config.
+     *
+     * @param value The interface name as defined in CURLOPT_INTERFACE.
+     */
+    static void setInterfaceName( const std::string& interfaceName );
+
+     /**
+     * Static function to get the network interface set using
+     * the @setInterfaceName.
+     *
+     * @returns the network interface set otherwise empty string.
+     */
+    static std::string getInterfaceName();
 private:
     /**
      * Frees and sets the following attributes to NULL:
@@ -312,7 +331,8 @@ private:
     curl_httppost* m_lastPost;
     /// Name for this handle.
     std::string m_id;
-
+    /// Interface name to be used for curl
+    static std::string m_interfaceName;
     /// If no id is provided by the user, we will generate it from this counter.
     static std::atomic<uint64_t> m_idGenerator;
 };
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
new file mode 100644
index 0000000..bff624b
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDelete.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpDeleteInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpDeleteInterface.
+class HttpDelete : public HttpDeleteInterface {
+public:
+    /**
+     * Create a new HttpDelete instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpDelete instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpDelete> create();
+
+    /**
+     * HttpDelete destructor
+     */
+    ~HttpDelete() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpDelete(const HttpDelete& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpDelete& operator=(const HttpDelete& rhs) = delete;
+
+    HTTPResponse doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpDelete constructor.
+     */
+    HttpDelete() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
new file mode 100644
index 0000000..14459fa
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpDeleteInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP DELETE requests.
+class HttpDeleteInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpDeleteInterface() = default;
+
+    /**
+     * Perform an HTTP DELETE request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the DELETE to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the DELETE request.
+     */
+    virtual HTTPResponse doDelete(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPDELETEINTERFACE_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
new file mode 100644
index 0000000..f19dfd6
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
+
+#include <memory>
+#include <mutex>
+#include <string>
+
+#include <curl/curl.h>
+
+#include "AVSCommon/Utils/LibcurlUtils/CurlEasyHandleWrapper.h"
+#include "HttpGetInterface.h"
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// LIBCURL based implementation of HttpGetInterface.
+class HttpGet : public HttpGetInterface {
+public:
+    /**
+     * Create a new HttpGet instance, passing ownership of the new instance on to the caller.
+     *
+     * @return Returns an std::unique_ptr to the new HttpGet instance, or @c nullptr of the operation failed.
+     */
+    static std::unique_ptr<HttpGet> create();
+
+    /**
+     * HttpGet destructor
+     */
+    ~HttpGet() = default;
+
+    /**
+     * Deleted copy constructor.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     */
+    HttpGet(const HttpGet& rhs) = delete;
+
+    /**
+     * Deleted assignment operator.
+     *
+     * @param rhs The 'right hand side' to not copy.
+     * @return The object assigned to.
+     */
+    HttpGet& operator=(const HttpGet& rhs) = delete;
+
+    HTTPResponse doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout) override;
+
+private:
+    /**
+     * Default HttpGet constructor.
+     */
+    HttpGet() = default;
+
+    /// Mutex to serialize access to @c m_curl.
+    std::mutex m_mutex;
+
+    /// CURL handle with which to make requests
+    CurlEasyHandleWrapper m_curl;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGET_H_
diff --git a/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
new file mode 100644
index 0000000..68573f0
--- /dev/null
+++ b/AVSCommon/Utils/include/AVSCommon/Utils/LibcurlUtils/HttpGetInterface.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+#define ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
+
+#include <chrono>
+#include <string>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/HTTPResponse.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+/// Minimal interface for making HTTP GET requests.
+class HttpGetInterface {
+public:
+    /// Virtual destructor to assure proper cleanup of derived types.
+    virtual ~HttpGetInterface() = default;
+
+    /**
+     * Perform an HTTP Get request returning the response body as a string. This method blocks for the duration
+     * of the request.
+     *
+     * @param url The URL to send the GET to.
+     * @param headers vector of strings to add in the header.
+     * @param timeout The maximum amount of time (in seconds) to wait for the request to complete.
+     * @return An object describing the response to the GET request.
+     */
+    virtual HTTPResponse doGet(
+        const std::string& url,
+        const std::vector<std::string>& headers,
+        std::chrono::seconds timeout) = 0;
+};
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
+
+#endif  // ALEXA_CLIENT_SDK_AVSCOMMON_UTILS_INCLUDE_AVSCOMMON_UTILS_LIBCURLUTILS_HTTPGETINTERFACE_H_
diff --git a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
index c3bda8f..df104c0 100644
--- a/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
+++ b/AVSCommon/Utils/src/LibcurlUtils/CurlEasyHandleWrapper.cpp
@@ -54,7 +54,8 @@ static const std::string LIBCURLUTILS_CONFIG_KEY = "libcurlUtils";
 static const std::string INTERFACE_CONFIG_KEY = "CURLOPT_INTERFACE";
 /// Counter used to geneate unique IDs.
 std::atomic<uint64_t> CurlEasyHandleWrapper::m_idGenerator{1};
-
+///  Interface used for the curl connection.
+std::string CurlEasyHandleWrapper::m_interfaceName{""};
 #ifdef ACSDK_EMIT_CURL_LOGS
 /// Key under 'acl' configuration node for path/prefix of per-stream log file names.
 static const std::string STREAM_LOG_PREFIX_KEY("streamLogPrefix");
@@ -242,6 +243,9 @@ bool CurlEasyHandleWrapper::setTransferType(TransferType type) {
         case TransferType::kPUT:
             ret = setopt(CURLOPT_UPLOAD, 1L);
             break;
+        case TransferType::kDELETE:
+            ret = setopt(CURLOPT_CUSTOMREQUEST, "DELETE");
+            break;
     }
     return ret;
 }
@@ -324,7 +328,14 @@ bool CurlEasyHandleWrapper::setDefaultOptions() {
 
         auto config = configuration::ConfigurationNode::getRoot()[LIBCURLUTILS_CONFIG_KEY];
         std::string interfaceName;
-        if (config.getString(INTERFACE_CONFIG_KEY, &interfaceName) &&
+        config.getString(INTERFACE_CONFIG_KEY, &interfaceName, "");
+
+        if (!m_interfaceName.empty()) {
+            // Override the config, if interface name is provided at runtime. 
+            interfaceName = m_interfaceName;
+        }
+
+        if (!interfaceName.empty() &&
             !setopt(CURLOPT_INTERFACE, interfaceName.c_str())) {
             break;
         }
@@ -372,6 +383,14 @@ CURLcode CurlEasyHandleWrapper::pause(int mask) {
     return CURLcode::CURLE_FAILED_INIT;
 }
 
+void CurlEasyHandleWrapper::setInterfaceName( const std::string& interfaceName ) {
+    m_interfaceName = interfaceName;
+}
+
+std::string CurlEasyHandleWrapper::getInterfaceName() {
+    return m_interfaceName;
+}
+
 #ifdef ACSDK_EMIT_CURL_LOGS
 void CurlEasyHandleWrapper::initStreamLog() {
     std::string streamLogPrefix;
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
new file mode 100644
index 0000000..129fca8
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpDelete.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpDelete.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpDelete");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpDelete> HttpDelete::create() {
+    std::unique_ptr<HttpDelete> httpDelete(new HttpDelete());
+    if (httpDelete->m_curl.isValid()) {
+        return httpDelete;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpDelete::doDelete(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doDeleteFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kDELETE)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
new file mode 100644
index 0000000..10e6836
--- /dev/null
+++ b/AVSCommon/Utils/src/LibcurlUtils/HttpGet.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *     http://aws.amazon.com/apache2.0/
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#include <cstdlib>
+#include <cstring>
+#include <vector>
+
+#include <AVSCommon/Utils/LibcurlUtils/CallbackData.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpResponseCodes.h>
+#include <AVSCommon/Utils/LibcurlUtils/HttpGet.h>
+#include <AVSCommon/Utils/Logger/Logger.h>
+
+namespace alexaClientSDK {
+namespace avsCommon {
+namespace utils {
+namespace libcurlUtils {
+
+using namespace alexaClientSDK::avsCommon::utils;
+
+/// String to identify log entries originating from this file.
+static const std::string TAG("HttpGet");
+
+/**
+ * Create a LogEntry using this file's TAG and the specified event string.
+ *
+ * @param The event string for this @c LogEntry.
+ */
+#define LX(event) alexaClientSDK::avsCommon::utils::logger::LogEntry(TAG, event)
+
+/**
+ * Write callback function used for CURLOPT_WRITEFUNCTION option in libcurl
+ */
+static size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream);
+
+std::unique_ptr<HttpGet> HttpGet::create() {
+    std::unique_ptr<HttpGet> httpGet(new HttpGet());
+    if (httpGet->m_curl.isValid()) {
+        return httpGet;
+    }
+    return nullptr;
+}
+
+HTTPResponse HttpGet::doGet(const std::string& url, const std::vector<std::string>& headers, std::chrono::seconds timeout ) {
+    std::lock_guard<std::mutex> lock(m_mutex);
+    const std::string errorEvent = "doGetFailed";
+    const std::string errorReasonKey = "reason";
+    HTTPResponse httpResponse;
+
+    if (!m_curl.reset()) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToResetCurlHandle"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferTimeout(static_cast<long>(timeout.count()))) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetTimeout"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setURL(url)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetUrl"));
+        return httpResponse;
+    }
+
+    if (!m_curl.setTransferType(CurlEasyHandleWrapper::TransferType::kGET)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetHttpRequestType"));
+        return httpResponse;
+    }
+
+    for (auto header : headers) {
+        if (!m_curl.addHTTPHeader(header)) {
+            ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToAddHttpHeader"));
+            return httpResponse;
+        }
+    }
+
+    CallbackData responseData;
+    if (!m_curl.setWriteCallback(writeCallback, &responseData)) {
+        ACSDK_ERROR(LX(errorEvent).d(errorReasonKey, "unableToSetWriteCallback"));
+        return httpResponse;
+    }
+
+    CURLcode curlResult = m_curl.perform();
+    if (curlResult != CURLE_OK) {
+        ACSDK_ERROR(
+            LX(errorEvent).d(errorReasonKey, "curlFailedWithCode: " + std::string(curl_easy_strerror(curlResult))));
+        return httpResponse;
+    }
+
+    size_t responseSize = responseData.getSize();
+    if (responseSize > 0) {
+        std::vector<char> responseBody(responseSize + 1, 0);
+        responseData.getData(responseBody.data(), responseSize);
+        httpResponse.body = std::string(responseBody.data());
+    } else {
+        httpResponse.body = "";
+    }
+    httpResponse.code = m_curl.getHTTPResponseCode();
+
+    return httpResponse;
+}
+
+size_t writeCallback(char* dataBuffer, size_t blockSize, size_t numBlocks, void* dataStream) {
+    if (!dataStream) {
+        ACSDK_ERROR(LX("writeCallbackFailed").d("reason", "nullDataStream"));
+        return 0;
+    }
+
+    size_t realSize = blockSize * numBlocks;
+    CallbackData* callbackData = reinterpret_cast<CallbackData*>(dataStream);
+
+    return callbackData->appendData(dataBuffer, realSize);
+}
+
+}  // namespace libcurlUtils
+}  // namespace utils
+}  // namespace avsCommon
+}  // namespace alexaClientSDK
diff --git a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
index 1b29073..7295d86 100644
--- a/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
+++ b/ApplicationUtilities/DefaultClient/src/DefaultClient.cpp
@@ -694,6 +694,7 @@ bool DefaultClient::initialize(
         contextManager,
         m_exceptionSender,
         m_playbackRouter,
+        m_certifiedSender,
         m_captionManager);
 #else
     m_audioPlayer = capabilityAgents::audioPlayer::AudioPlayer::create(
@@ -703,6 +704,7 @@ bool DefaultClient::initialize(
         contextManager,
         m_exceptionSender,
         m_playbackRouter,
+        m_certifiedSender,
         nullptr);
 #endif
     if (!m_audioPlayer) {
diff --git a/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp b/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
index d409921..f5a6467 100644
--- a/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
+++ b/CapabilitiesDelegate/src/PostConnectCapabilitiesPublisher.cpp
@@ -52,7 +52,7 @@ static const std::vector<int> RETRY_TABLE = {
 static avsCommon::utils::RetryTimer RETRY_TIMER{RETRY_TABLE};
 
 /// Maximum number of endpoints per event.
-static const int MAX_ENDPOINTS_PER_EVENT = 300;
+static const int MAX_ENDPOINTS_PER_EVENT = 40;
 
 /// The timeout for the Asynchronous response directive (Alexa.EventProcessed) to be received.
 static const auto ASYNC_RESPONSE_TIMEOUT = std::chrono::seconds(2);
@@ -124,7 +124,7 @@ MessageRequestObserverInterface::Status PostConnectCapabilitiesPublisher::sendDi
     const std::shared_ptr<PostConnectSendMessageInterface>& postConnectSender,
     const std::string& eventString,
     bool waitForEventProcessed) {
-    ACSDK_DEBUG5(LX(__func__));
+    ACSDK_DEBUG5(LX(__func__).sensitive("discoveryEvent", eventString));
     std::unique_lock<std::mutex> lock{m_mutex};
     m_eventProcessedWaitEvent.reset();
     m_postConnectRequest.reset();
diff --git a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
index c0ff0d7..b2dd30f 100644
--- a/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
+++ b/CapabilitiesDelegate/src/Utils/DiscoveryUtils.cpp
@@ -67,6 +67,8 @@ const static std::string FRIENDLY_NAME_KEY = "friendlyName";
 const static std::string DESCRIPTION_KEY = "description";
 /// Manufacturer name key
 const static std::string MANUFACTURER_NAME_KEY = "manufacturerName";
+/// EndpointResources ID key
+const static std::string ENDPOINTRESOURCES_KEY = "endpointResources";
 /// Display Categories key
 const static std::string DISPLAY_CATEGORIES_KEY = "displayCategories";
 /// Additional Attributes key
@@ -230,14 +232,18 @@ bool validateEndpointAttributes(const AVSDiscoveryEndpointAttributes& endpointAt
         return false;
     }
 
-    if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
-        return false;
-    }
+    if (!endpoints::isEndpointResourcesValid(endpointAttributes.endpointResources)) {
 
-    if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
-        ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
-        return false;
+    // Validate the legacy fields if the endpointResources object is invalid.
+        if (!endpoints::isDescriptionValid(endpointAttributes.description)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidDescription"));
+            return false;
+        }
+
+        if (!endpoints::isManufacturerNameValid(endpointAttributes.manufacturerName)) {
+            ACSDK_ERROR(LX("validateEndpointAttributesFailed").d("reason", "invalidManufacturerName"));
+            return false;
+        }
     }
 
     if (endpointAttributes.displayCategories.empty()) {
@@ -254,9 +260,15 @@ std::string getEndpointConfigJson(
     JsonGenerator generator;
 
     generator.addMember(ENDPOINT_ID_KEY, endpointAttributes.endpointId);
-    generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
-    generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
-    generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+
+    /// Endpoint Resources.
+    if (endpointAttributes.endpointResources.isValid()) {
+        generator.addRawJsonMember(ENDPOINTRESOURCES_KEY, endpointAttributes.endpointResources.build());
+    } else {
+        generator.addMember(FRIENDLY_NAME_KEY, endpointAttributes.friendlyName);
+        generator.addMember(DESCRIPTION_KEY, endpointAttributes.description);
+        generator.addMember(MANUFACTURER_NAME_KEY, endpointAttributes.manufacturerName);
+    }
 
     generator.addStringArray(DISPLAY_CATEGORIES_KEY, endpointAttributes.displayCategories);
 
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
index af0ff6a..780ffce 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertObserverInterface.h
@@ -74,6 +74,29 @@ public:
         State state,
         const std::string& reason = "") = 0;
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    virtual void onAlertCreated(const std::string& alertToken, const std::string& detailedInfo) {};
+
+    /**
+     * A callback function to notify an object that an alert has been deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    virtual void onAlertDeleted(const std::string& alertToken) {};
+
     /**
      * Convert a @c State to a @c std::string.
      *
diff --git a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
index 8c7b9cf..74de4ca 100644
--- a/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
+++ b/CapabilityAgents/Alerts/include/Alerts/AlertsCapabilityAgent.h
@@ -288,6 +288,32 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason);
 
+    /**
+     * A callback function to notify an object that an alert has been created with additional information about the alert.
+     *
+     * @param alertToken The AVS token of the alert.
+     * @param detailedInfo The JSON payload of detailed alert info :
+     * {
+     *      "time" : <String>
+     *      "type" : <String>
+     *      "label" : <String>
+     * }
+     * time The time string ( Scheduled Time ISO_8601 ).
+     * type The type of the alert ( ALERT, REMINDER, TIMER ).
+     * label The label of the TIMER, description for REMINDER, or empty string for ALARM.
+     */
+    void executeOnAlertCreated(
+        const std::string& alertToken,
+        const std::string& jsonPayload);
+
+    /**
+     * A handler function which will be called by our internal executor when an alert is deleted.
+     *
+     * alertToken The AVS token of the alert.
+     */
+    void executeOnAlertDeleted(
+        const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to add an alert observer.
      *
@@ -316,6 +342,21 @@ private:
         AlertObserverInterface::State state,
         const std::string& reason = "");
 
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of detailed alert info.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     * @param jsonInfo The detailed JSON info. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertCreatedObservers(const std::string& alertToken, const std::string& jsonInfo);
+
+    /**
+     * A handler function which will be called by our internal executor to notify the observer of an alert deleted.
+     *
+     * @param alertToken The alert token. See AlertObserverInterface for more.
+     */
+    void executeNotifyAlertDeletedObservers(const std::string& alertToken);
+
     /**
      * A handler function which will be called by our internal executor to remove all alerts currently being managed.
      */
diff --git a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
index 37f3535..34fa86f 100644
--- a/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
+++ b/CapabilityAgents/Alerts/src/AlertsCapabilityAgent.cpp
@@ -66,6 +66,9 @@ static const std::string ALERTS_CAPABILITY_INTERFACE_VERSION = "1.4";
 /// The value for Type which we need for json parsing.
 static const std::string KEY_TYPE = "type";
 
+/// The value for Label which we need for json parsing.
+static const std::string KEY_LABEL = "label";
+
 // ==== Directives ===
 
 /// The value of the SetAlert Directive.
@@ -524,6 +527,27 @@ bool AlertsCapabilityAgent::handleSetAlert(
 
     updateContextManager();
 
+    Document document( rapidjson::kObjectType );
+    document.AddMember("time", parsedAlert->getScheduledTime_ISO_8601(), document.GetAllocator());
+    document.AddMember("type", parsedAlert->getTypeName(), document.GetAllocator());
+    std::string label;
+    if (!retrieveValue(payload, KEY_LABEL, &label)) {
+        document.AddMember("label", "", document.GetAllocator());
+    } else {
+        document.AddMember("label", label, document.GetAllocator());
+    }
+    // build the json state string
+    rapidjson::StringBuffer buffer;
+    rapidjson::Writer<rapidjson::StringBuffer> writer( buffer );
+
+    if (!document.Accept( writer )) {
+        ACSDK_ERROR(LX("failedToWriteJsonDocument").m("Alert DetailedInfo not sent"));
+    } else {
+        std::string payload = buffer.GetString();
+        std::string token = parsedAlert->getToken();
+        m_executor.submit([this, token, payload]() { executeOnAlertCreated( token, payload); });
+    }
+
     return true;
 }
 
@@ -543,6 +567,9 @@ bool AlertsCapabilityAgent::handleDeleteAlert(
 
     updateContextManager();
 
+    std::string token = *alertToken;
+    m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
+
     return true;
 }
 
@@ -572,6 +599,8 @@ bool AlertsCapabilityAgent::handleDeleteAlerts(
         if (!convertToValue(tokenArray[i], &token)) {
             ACSDK_WARN(LX("handleDeleteAlertsFailed").d("reason", "invalid token in payload"));
             continue;
+        } else {
+            m_executor.submit([this, token]() { executeOnAlertDeleted(token); });
         }
         alertTokens.push_back(token);
     }
@@ -936,6 +965,14 @@ void AlertsCapabilityAgent::executeOnAlertStateChange(
     });
 }
 
+void AlertsCapabilityAgent::executeOnAlertCreated(const std::string& alertToken, const std::string& payload){
+    m_executor.submit([this, alertToken, payload]() { executeNotifyAlertCreatedObservers(alertToken, payload); });
+}
+
+void AlertsCapabilityAgent::executeOnAlertDeleted(const std::string& alertToken){
+    m_executor.submit([this, alertToken]() { executeNotifyAlertDeletedObservers(alertToken); });
+}
+
 void AlertsCapabilityAgent::executeAddObserver(std::shared_ptr<AlertObserverInterface> observer) {
     ACSDK_DEBUG1(LX("executeAddObserver").d("observer", observer.get()));
     m_observers.insert(observer);
@@ -961,6 +998,23 @@ void AlertsCapabilityAgent::executeNotifyObservers(
     }
 }
 
+void AlertsCapabilityAgent::executeNotifyAlertCreatedObservers(
+    const std::string& alertToken,
+    const std::string& payload) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertCreatedObservers").d("alertToken", alertToken).sensitive("payload", payload));
+    for (auto observer : m_observers) {
+        observer->onAlertCreated(alertToken, payload);
+    }
+}
+
+void AlertsCapabilityAgent::executeNotifyAlertDeletedObservers(
+    const std::string& alertToken) {
+        ACSDK_DEBUG1(LX("executeNotifyAlertDeletedObservers").d("alertToken", alertToken));
+    for (auto observer : m_observers) {
+        observer->onAlertDeleted(alertToken);
+    }
+}
+
 void AlertsCapabilityAgent::executeRemoveAllAlerts() {
     ACSDK_DEBUG1(LX("executeRemoveAllAlerts"));
     m_alertScheduler.clearData();
diff --git a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
index 49df3c9..feb7d9e 100644
--- a/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
+++ b/CapabilityAgents/AudioPlayer/include/AudioPlayer/AudioPlayer.h
@@ -42,6 +42,7 @@
 #include <AVSCommon/Utils/Timing/Timer.h>
 #include <AVSCommon/Utils/Timing/TimeUtils.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
 
 #include "AudioItem.h"
 #include "ClearBehavior.h"
@@ -90,6 +91,7 @@ public:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr);
 
     /// @name StateProviderInterface Functions
@@ -229,6 +231,7 @@ private:
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
         std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionSender,
         std::shared_ptr<avsCommon::sdkInterfaces::PlaybackRouterInterface> playbackRouter,
+        std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
         std::shared_ptr<captions::CaptionManagerInterface> captionManager = nullptr);
 
     /// @name RequiresShutdown Functions
@@ -660,6 +663,10 @@ private:
      *     before the Executor Thread Variables are destroyed.
      */
     avsCommon::utils::threading::Executor m_executor;
+
+    /// The CertifiedSender object.
+    std::shared_ptr<certifiedSender::CertifiedSender> m_certifiedSender;
+
 };
 
 }  // namespace audioPlayer
diff --git a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
index 340abe3..a440b7b 100644
--- a/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
+++ b/CapabilityAgents/AudioPlayer/src/AudioPlayer.cpp
@@ -38,6 +38,7 @@ using namespace avsCommon::utils;
 using namespace avsCommon::utils::json;
 using namespace avsCommon::utils::logger;
 using namespace avsCommon::utils::mediaPlayer;
+using namespace certifiedSender;
 
 /// AudioPlayer capability constants
 /// AudioPlayer interface type
@@ -151,6 +152,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager) {
     if (nullptr == mediaPlayerFactory) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMediaPlayerFactory"));
@@ -170,8 +172,12 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
     } else if (nullptr == playbackRouter) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullPlaybackRouter"));
         return nullptr;
+    } else if (nullptr == certifiedMessageSender) {
+        ACSDK_ERROR(LX("createFailed").d("reason", "nullCertifiedMessageSender"));
+        return nullptr;
     }
 
+
     auto audioPlayer = std::shared_ptr<AudioPlayer>(new AudioPlayer(
         std::move(mediaPlayerFactory),
         messageSender,
@@ -179,6 +185,7 @@ std::shared_ptr<AudioPlayer> AudioPlayer::create(
         contextManager,
         exceptionSender,
         playbackRouter,
+        certifiedMessageSender,
         captionManager));
     contextManager->setStateProvider(STATE, audioPlayer);
     audioPlayer->m_mediaPlayerFactory->addObserver(audioPlayer);
@@ -477,6 +484,7 @@ AudioPlayer::AudioPlayer(
     std::shared_ptr<ContextManagerInterface> contextManager,
     std::shared_ptr<ExceptionEncounteredSenderInterface> exceptionSender,
     std::shared_ptr<PlaybackRouterInterface> playbackRouter,
+    std::shared_ptr<certifiedSender::CertifiedSender> certifiedMessageSender,
     std::shared_ptr<captions::CaptionManagerInterface> captionManager) :
         CapabilityAgent{NAMESPACE, exceptionSender},
         RequiresShutdown{"AudioPlayer"},
@@ -491,7 +499,8 @@ AudioPlayer::AudioPlayer(
         m_currentlyPlaying(std::make_shared<PlayDirectiveInfo>("")),
         m_offset{std::chrono::milliseconds{std::chrono::milliseconds::zero()}},
         m_isStopCalled{false},
-        m_okToRequestNextTrack{false} {
+        m_okToRequestNextTrack{false},
+        m_certifiedSender{certifiedMessageSender} {
     m_capabilityConfigurations.insert(getAudioPlayerCapabilityConfiguration());
 }
 
@@ -518,6 +527,7 @@ void AudioPlayer::doShutdown() {
     m_audioPlayQueue.clear();
     m_playbackRouter.reset();
     m_captionManager.reset();
+    m_certifiedSender.reset();
 }
 
 bool AudioPlayer::parseDirectivePayload(std::shared_ptr<DirectiveInfo> info, rapidjson::Document* document) {
@@ -1285,6 +1295,7 @@ bool AudioPlayer::configureMediaPlayer(std::shared_ptr<PlayDirectiveInfo>& playb
                     ErrorType::MEDIA_ERROR_INTERNAL_DEVICE_ERROR,
                     "failed to set attachment media source");
                 ACSDK_ERROR(LX("configureMediaPlayerFailed").d("reason", "setSourceFailed").d("type", "attachment"));
+                m_mediaPlayerFactory->releaseMediaPlayer(mediaPlayer);
                 return false;
             }
         } else {
@@ -1297,6 +1308,7 @@ bool AudioPlayer::configureMediaPlayer(std::shared_ptr<PlayDirectiveInfo>& playb
                     ErrorType::MEDIA_ERROR_INTERNAL_DEVICE_ERROR,
                     "failed to set URL media source");
                 ACSDK_ERROR(LX("configureMediaPlayerFailed").d("reason", "setSourceFailed").d("type", "URL"));
+                m_mediaPlayerFactory->releaseMediaPlayer(mediaPlayer);
                 return false;
             }
         }
@@ -1420,14 +1432,14 @@ void AudioPlayer::executePrePlay(std::shared_ptr<PlayDirectiveInfo> info) {
 void AudioPlayer::executePlay(const std::string& messageId) {
     ACSDK_DEBUG1(LX(__func__));
 
-    auto playItem = m_audioPlayQueue.front();
-
     if (m_audioPlayQueue.empty()) {
         ACSDK_ERROR(
-            LX("executePlayFailed").d("reason", "unhandledPlayBehavior").d("playBehavior", playItem->playBehavior));
+            LX("executePlayFailed").d("reason", "emptyPlayQueue").d("messageId", messageId));
         return;
     }
 
+    auto playItem = m_audioPlayQueue.front();
+
     if (playItem->playBehavior != PlayBehavior::ENQUEUE && playItem->messageId != messageId) {
         ACSDK_ERROR(LX("executePlayFailed").d("reason", "TrackNotHeadOfQueue"));
         return;
@@ -1607,6 +1619,10 @@ void AudioPlayer::sendEventWithTokenAndOffset(const std::string& eventName, std:
     }
 
     auto event = buildJsonEventString(eventName, "", buffer.GetString());
+    if (eventName == "PlaybackNearlyFinished" || eventName == "PlaybackFinished" ) {
+        m_certifiedSender->sendJSONMessage(event.second);
+        return;
+    }
     auto request = std::make_shared<MessageRequest>(event.second);
     m_messageSender->sendMessage(request);
 }
diff --git a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
index 1d650e6..23362e8 100644
--- a/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
+++ b/CapabilityAgents/AudioPlayer/src/CMakeLists.txt
@@ -4,10 +4,15 @@ add_library(AudioPlayer SHARED
     ProgressTimer.cpp)
 target_include_directories(AudioPlayer PUBLIC
     "${AudioPlayer_SOURCE_DIR}/include"
+    "${CertifiedSender_SOURCE_DIR}/include"
+    "${SQLiteStorage_SOURCE_DIR}/include"
     "${AVSCommon_INCLUDE_DIRS}")
 target_link_libraries(AudioPlayer
     Captions
-    AVSCommon)
+    AVSCommon
+    CertifiedSender 
+    SQLiteStorage)
+
 
 # install target
 asdk_install()
diff --git a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
index 4a2d1f4..1ffe920 100644
--- a/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
+++ b/CapabilityAgents/AudioPlayer/test/AudioPlayerTest.cpp
@@ -37,6 +37,7 @@
 #include <AVSCommon/SDKInterfaces/MockFocusManager.h>
 #include <AVSCommon/SDKInterfaces/MockMessageSender.h>
 #include <AVSCommon/SDKInterfaces/MockPlaybackRouter.h>
+#include <AVSCommon/SDKInterfaces/MockAVSConnectionManager.h>
 #include <AVSCommon/Utils/JSON/JSONUtils.h>
 #include <AVSCommon/Utils/Logger/ConsoleLogger.h>
 #include <AVSCommon/Utils/MediaPlayer/MockMediaPlayer.h>
@@ -65,6 +66,8 @@ using namespace captions::test;
 using namespace avsCommon::utils::mediaPlayer::test;
 using namespace ::testing;
 using namespace rapidjson;
+using namespace certifiedSender;
+using namespace registrationManager;
 
 /// Plenty of time for a test to complete.
 static std::chrono::milliseconds WAIT_TIMEOUT(1000);
@@ -394,6 +397,43 @@ static const std::string STREAM_METADATA_EXTRACTED_NAME = "StreamMetadataExtract
 /// String to identify log entries originating from this file.
 static const std::string TAG("AudioPlayerTest");
 
+    /**
+     * Test @c MessageStorageInterface implementation to provide a valid instance for the initialization of other
+     * components.
+     */
+    class StubMessageStorage : public MessageStorageInterface {
+    public:
+        bool createDatabase() override {
+            return true;
+        }
+        
+        bool open() override {
+            return true;
+        }
+        
+        void close() override {
+        }
+        
+        bool store(const std::string& message, int* id) override {
+            return true;
+        }
+        
+        bool store(const std::string& message, const std::string& uriPathExtension, int* id) override {
+            return true;
+        }
+        
+        bool load(std::queue<StoredMessage>* messageContainer) override {
+            return true;
+        }
+        
+        bool erase(int messageId) override {
+            return true;
+        }
+        
+        bool clearDatabase() override {
+            return true;
+        }
+    };
 /**
  * Create a LogEntry using this file's TAG and the specified event string.
  *
@@ -490,6 +530,15 @@ public:
     /// Identifier for the currently selected audio source.
     MediaPlayerInterface::SourceId m_sourceId;
 
+    std::shared_ptr<MockAVSConnectionManager> m_mockAVSConnectionManager;
+
+    std::shared_ptr<StubMessageStorage> m_messageStorage;
+
+    std::shared_ptr<CustomerDataManager> m_customerDataManager;
+
+    std::shared_ptr<CertifiedSender> m_certifiedSender;
+
+
     /**
      * This is invoked in response to a @c setState call.
      *
@@ -655,6 +704,12 @@ void AudioPlayerTest::SetUp() {
         m_mockMediaPlayer, m_mockMediaPlayerTrack2, m_mockMediaPlayerTrack3};
     m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool);
     m_mockCaptionManager = std::make_shared<NiceMock<MockCaptionManager>>();
+    m_mockAVSConnectionManager = std::make_shared<NiceMock<MockAVSConnectionManager>>();
+    m_messageStorage = std::make_shared<StubMessageStorage>();
+
+    m_certifiedSender = CertifiedSender::create(
+        m_mockMessageSender, m_mockAVSConnectionManager, m_messageStorage, m_customerDataManager);
+
     m_audioPlayer = AudioPlayer::create(
         std::move(m_mockFactory),
         m_mockMessageSender,
@@ -662,6 +717,7 @@ void AudioPlayerTest::SetUp() {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
 
     ASSERT_TRUE(m_audioPlayer);
@@ -703,7 +759,8 @@ void AudioPlayerTest::reSetUp(int numberOfPlayers) {
         m_mockFocusManager,
         m_mockContextManager,
         m_mockExceptionSender,
-        m_mockPlaybackRouter);
+        m_mockPlaybackRouter,
+        m_certifiedSender);
 
     ASSERT_TRUE(m_audioPlayer);
 
@@ -908,6 +965,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -919,6 +977,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -930,6 +989,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -941,6 +1001,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         nullptr,
         m_mockExceptionSender,
         m_mockPlaybackRouter,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -952,6 +1013,19 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockContextManager,
         nullptr,
         m_mockPlaybackRouter,
+        m_certifiedSender,
+        m_mockCaptionManager);
+    EXPECT_EQ(testAudioPlayer, nullptr);
+
+    m_mockFactory = alexaClientSDK::mediaPlayer::PooledMediaPlayerFactory::create(pool);
+    testAudioPlayer = AudioPlayer::create(
+        std::move(m_mockFactory),
+        m_mockMessageSender,
+        m_mockFocusManager,
+        m_mockContextManager,
+        m_mockExceptionSender,
+        nullptr,
+        m_certifiedSender,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
 
@@ -962,6 +1036,7 @@ TEST_F(AudioPlayerTest, test_createWithNullPointers) {
         m_mockFocusManager,
         m_mockContextManager,
         m_mockExceptionSender,
+        m_mockPlaybackRouter,
         nullptr,
         m_mockCaptionManager);
     EXPECT_EQ(testAudioPlayer, nullptr);
diff --git a/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h b/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
index ba38ff3..0a80190 100644
--- a/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
+++ b/CapabilityAgents/DoNotDisturb/include/DoNotDisturbCA/DoNotDisturbCapabilityAgent.h
@@ -50,11 +50,11 @@ namespace doNotDisturb {
  */
 class DoNotDisturbCapabilityAgent
         : public std::enable_shared_from_this<DoNotDisturbCapabilityAgent>
-        , public avsCommon::avs::CapabilityAgent
-        , public avsCommon::sdkInterfaces::CapabilityConfigurationInterface
-        , public avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
-        , public avsCommon::utils::RequiresShutdown
-        , public settings::SettingEventSenderInterface {
+        , public alexaClientSDK::avsCommon::avs::CapabilityAgent
+        , public alexaClientSDK::avsCommon::sdkInterfaces::CapabilityConfigurationInterface
+        , public alexaClientSDK::avsCommon::sdkInterfaces::ConnectionStatusObserverInterface
+        , public alexaClientSDK::avsCommon::utils::RequiresShutdown
+        , public alexaClientSDK::settings::SettingEventSenderInterface {
 public:
     /**
      * Destructor.
@@ -70,22 +70,22 @@ public:
      * @return A new instance of @c DoNotDisturbCapabilityAgent on success, @c nullptr otherwise.
      */
     static std::shared_ptr<DoNotDisturbCapabilityAgent> create(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
-        std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /// @name CapabilityAgent Functions
     /// @{
-    avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
-    void handleDirectiveImmediately(std::shared_ptr<avsCommon::avs::AVSDirective> directive) override;
-    void preHandleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void handleDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
-    void cancelDirective(std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    alexaClientSDK::avsCommon::avs::DirectiveHandlerConfiguration getConfiguration() const override;
+    void handleDirectiveImmediately(std::shared_ptr<alexaClientSDK::avsCommon::avs::AVSDirective> directive) override;
+    void preHandleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void handleDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
+    void cancelDirective(std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info) override;
     /// @}
 
     /// @name CapabilityConfigurationInterface Functions
     /// @{
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> getCapabilityConfigurations() override;
     /// @}
 
     // @name RequiresShutdown Functions
@@ -118,7 +118,7 @@ public:
      *
      * @return The do not disturb events metadata.
      */
-    static settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
+    static alexaClientSDK::settings::SettingEventMetadata getDoNotDisturbEventsMetadata();
 
 private:
     /**
@@ -128,8 +128,8 @@ private:
      * @param messageSender Interface to send events to AVS.
      */
     DoNotDisturbCapabilityAgent(
-        std::shared_ptr<avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::ExceptionEncounteredSenderInterface> exceptionEncounteredSender,
+        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
 
     /**
      * Method to initialize the new instance of the capability agent.
@@ -137,7 +137,7 @@ private:
      * @param settingsStorage The storage interface that will be used to store device settings.
      * @return True on success, false otherwise.
      */
-    bool initialize(std::shared_ptr<settings::storage::DeviceSettingStorageInterface> settingsStorage);
+    bool initialize(std::shared_ptr<alexaClientSDK::settings::storage::DeviceSettingStorageInterface> settingsStorage);
 
     /**
      * Sends a DND event to the AVS.
@@ -146,7 +146,7 @@ private:
      * @param value Valid JSON string representation of the boolean value. I.e. either "true" or "false".
      * @return Future to track the completion status of the message.
      */
-    std::shared_future<avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
+    std::shared_future<alexaClientSDK::avsCommon::sdkInterfaces::MessageRequestObserverInterface::Status> sendDNDEvent(
         const std::string& eventName,
         const std::string& value);
 
@@ -164,17 +164,17 @@ private:
      * implies that exception has been reported to AVS and directive is already processed.
      */
     bool handleSetDoNotDisturbDirective(
-        std::shared_ptr<avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
+        std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityAgent::DirectiveInfo> info,
         rapidjson::Document& document);
 
     /// Set of capability configurations that will get published using DCF
-    std::unordered_set<std::shared_ptr<avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
+    std::unordered_set<std::shared_ptr<alexaClientSDK::avsCommon::avs::CapabilityConfiguration>> m_capabilityConfigurations;
 
     /// The @c MessageSenderInterface used to send event messages.
-    std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
+    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::MessageSenderInterface> m_messageSender;
 
     /// The do not disturb mode setting.
-    std::shared_ptr<settings::Setting<bool>> m_dndModeSetting;
+    std::shared_ptr<alexaClientSDK::settings::Setting<bool>> m_dndModeSetting;
 
     /**
      * Flag indicating latest reported connection status. True if SDK is connected to the AVS and ready,
diff --git a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
index 8775551..ffc28d2 100644
--- a/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
+++ b/CapabilityAgents/MRM/include/MRM/MRMCapabilityAgent.h
@@ -107,7 +107,7 @@ public:
 
     /// @name Overridden @c CallStateObserverInterface methods
     /// @{
-    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) override;
+    void onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) override;
     /// @}
 
     /// @name Overridden CapabilityConfigurationInterface methods.
@@ -182,7 +182,7 @@ private:
     /**
      * This function handles when the CallState has been changed.
      */
-    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state);
+    void executeOnCallStateChange(const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState state, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo);
 
     /**
      * This function handles when a System.UserInactivityReport has been sent to
@@ -213,4 +213,4 @@ private:
 }  // namespace capabilityAgents
 }  // namespace alexaClientSDK
 
-#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MRM_INCLUDE_MRM_MRMCAPABILITYAGENT_H_
\ No newline at end of file
+#endif  // ALEXA_CLIENT_SDK_CAPABILITYAGENTS_MRM_INCLUDE_MRM_MRMCAPABILITYAGENT_H_
diff --git a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
index 03b9700..8dadc58 100644
--- a/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
+++ b/CapabilityAgents/MRM/src/MRMCapabilityAgent.cpp
@@ -153,9 +153,9 @@ void MRMCapabilityAgent::onSpeakerSettingsChanged(
     m_executor.submit([this, type]() { executeOnSpeakerSettingsChanged(type); });
 }
 
-void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+void MRMCapabilityAgent::onCallStateChange(avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__).d("callState", callState));
-    m_executor.submit([this, callState]() { executeOnCallStateChange(callState); });
+    m_executor.submit([this, callState, displayInfo]() { executeOnCallStateChange(callState, displayInfo); });
 }
 
 std::string MRMCapabilityAgent::getVersionString() const {
@@ -206,7 +206,7 @@ void MRMCapabilityAgent::executeSetObserver(
 }
 
 void MRMCapabilityAgent::executeOnCallStateChange(
-    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState) {
+    const avsCommon::sdkInterfaces::CallStateObserverInterface::CallState callState, const avsCommon::sdkInterfaces::CallStateObserverInterface::CallDisplayInfo& displayInfo) {
     ACSDK_DEBUG5(LX(__func__));
     bool active =
         (CallStateObserverInterface::CallState::CONNECTING == callState ||
diff --git a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
index 078dc4c..c02d9f5 100644
--- a/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
+++ b/CapabilityAgents/PlaybackController/include/PlaybackController/PlaybackController.h
@@ -25,6 +25,7 @@
 #include <AVSCommon/SDKInterfaces/CapabilityConfigurationInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/ContextRequesterInterface.h>
+#include <AVSCommon/SDKInterfaces/FocusManagerInterface.h>
 #include <AVSCommon/SDKInterfaces/MessageSenderInterface.h>
 #include <AVSCommon/SDKInterfaces/PlaybackHandlerInterface.h>
 #include <AVSCommon/Utils/RequiresShutdown.h>
@@ -48,11 +49,14 @@ public:
      *
      * @param contextManager The @c ContextManagerInterface used to generate system context for events.
      * @param messageSender The @c MessageSenderInterface that sends events to AVS.
+     * @param focusManager The optional @c FocusManagerInterface that manages channel focus if the 
+     * @c PlaybackController should release the content channel on 'Pause' button press
      * @return @c nullptr if the inputs are not defined, else a new instance of @c PlaybackController.
      */
     static std::shared_ptr<PlaybackController> create(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     /**
      * Destructor.
@@ -92,10 +96,13 @@ private:
      *
      * @param contextManager The AVS Context manager used to generate system context for events.
      * @param messageSender The message sender interface that sends events to AVS.
+     * @param focusManager The optional channel focus manager if the @c PlaybackController should release the content 
+     * channel on 'Pause' button press
      */
     PlaybackController(
         std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> contextManager,
-        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender);
+        std::shared_ptr<avsCommon::sdkInterfaces::MessageSenderInterface> messageSender,
+        std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> focusManager = nullptr);
 
     // @name RequiresShutdown Functions
     /// @{
@@ -123,6 +130,9 @@ private:
     /// The @c ContextManager used to generate system context for events.
     std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface> m_contextManager;
 
+    /// The @c FocusManager used to manage usage of the content channel.
+    std::shared_ptr<avsCommon::sdkInterfaces::FocusManagerInterface> m_focusManager;
+
     /// The queue for storing the commands.
     std::queue<const PlaybackCommand*> m_commands;
     /// @}
diff --git a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
index f29ae74..8a99117 100644
--- a/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
+++ b/CapabilityAgents/PlaybackController/src/PlaybackController.cpp
@@ -50,6 +50,12 @@ static const std::string TAG("PlaybackController");
 /// String to identify the AVS namespace of the event we send.
 static const std::string PLAYBACK_CONTROLLER_NAMESPACE = "PlaybackController";
 
+/// The name of the @c FocusManager channel used by @c PlaybackController.
+static const std::string CHANNEL_NAME = avsCommon::sdkInterfaces::FocusManagerInterface::CONTENT_CHANNEL_NAME;
+
+/// The name of the @c PlaybackController pause command event.
+static const std::string PAUSE_EVENT_NAME = "PauseCommandIssued";
+
 /**
  * Creates the PlaybackController capability configuration.
  *
@@ -59,7 +65,8 @@ static std::shared_ptr<CapabilityConfiguration> getPlaybackControllerCapabilityC
 
 std::shared_ptr<PlaybackController> PlaybackController::create(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) {
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) {
     if (!contextManager) {
         ACSDK_ERROR(LX("createFailed").d("reason", "nullContextManager"));
         return nullptr;
@@ -68,14 +75,14 @@ std::shared_ptr<PlaybackController> PlaybackController::create(
         ACSDK_ERROR(LX("createFailed").d("reason", "nullMessageSender"));
         return nullptr;
     }
-
-    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender));
+    return std::shared_ptr<PlaybackController>(new PlaybackController(contextManager, messageSender, focusManager));
 }
 
 void PlaybackController::doShutdown() {
     m_executor.shutdown();
     m_messageSender.reset();
     m_contextManager.reset();
+    m_focusManager.reset();
 }
 
 void PlaybackController::handleCommand(const PlaybackCommand& command) {
@@ -126,10 +133,16 @@ void PlaybackController::onContextAvailable(const std::string& jsonContext) {
         auto& command = *m_commands.front();
         m_commands.pop();
 
-        auto msgIdAndJsonEvent = buildJsonEventString(
-            PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
-        m_messageSender->sendMessage(
-            std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        if (command.getEventName() == PAUSE_EVENT_NAME && m_focusManager != nullptr) {
+            ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("skippingPauseCommandIssued").m("releasingFocus"));
+            m_focusManager->releaseChannel(CHANNEL_NAME);
+        } else {
+            auto msgIdAndJsonEvent = buildJsonEventString(
+                PLAYBACK_CONTROLLER_NAMESPACE, command.getEventName(), "", command.getEventPayload(), jsonContext);
+            m_messageSender->sendMessage(
+                std::make_shared<PlaybackMessageRequest>(command, msgIdAndJsonEvent.second, shared_from_this()));
+        }
+
         if (!m_commands.empty()) {
             ACSDK_DEBUG9(LX("onContextAvailableExecutor").m("Queue is not empty, call getContext()."));
             m_contextManager->getContext(shared_from_this());
@@ -164,10 +177,12 @@ void PlaybackController::onContextFailure(const ContextRequestError error) {
 
 PlaybackController::PlaybackController(
     std::shared_ptr<ContextManagerInterface> contextManager,
-    std::shared_ptr<MessageSenderInterface> messageSender) :
+    std::shared_ptr<MessageSenderInterface> messageSender,
+    std::shared_ptr<FocusManagerInterface> focusManager) :
         RequiresShutdown{"PlaybackController"},
         m_messageSender{messageSender},
-        m_contextManager{contextManager} {
+        m_contextManager{contextManager},
+        m_focusManager{focusManager} {
     m_capabilityConfigurations.insert(getPlaybackControllerCapabilityConfiguration());
 }
 
diff --git a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
index ec148c0..7592c35 100644
--- a/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/src/SpeechSynthesizer.cpp
@@ -230,8 +230,12 @@ void SpeechSynthesizer::handleDirective(std::shared_ptr<DirectiveInfo> info) {
 }
 
 void SpeechSynthesizer::cancelDirective(std::shared_ptr<DirectiveInfo> info) {
-    ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
-    m_executor.submit([this, info]() { executeCancel(info); });
+    if (info && info->directive) {
+        ACSDK_DEBUG9(LX("cancelDirective").d("messageId", info->directive->getMessageId()));
+        m_executor.submit([this, info]() { executeCancel(info); });
+    } else {
+        ACSDK_WARN(LX("cancelDirective").d("reason", "infoNotAvailable"));
+    }
 }
 
 void SpeechSynthesizer::onFocusChanged(FocusState newFocus) {
@@ -937,8 +941,12 @@ std::string SpeechSynthesizer::buildPayload(std::string& token) {
 
 void SpeechSynthesizer::startPlaying() {
     ACSDK_DEBUG9(LX("startPlaying"));
-    std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
-    m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    if (m_currentInfo && m_currentInfo->attachmentReader) {
+        std::shared_ptr<AttachmentReader> attachmentReader = std::move(m_currentInfo->attachmentReader);
+        m_mediaSourceId = m_speechPlayer->setSource(std::move(attachmentReader));
+    } else {
+        m_mediaSourceId = MediaPlayerInterface::ERROR;
+    }
     if (m_captionManager && m_currentInfo->captionData.isValid()) {
         m_captionManager->onCaption(m_mediaSourceId, m_currentInfo->captionData);
     }
@@ -1004,9 +1012,14 @@ void SpeechSynthesizer::setDesiredState(SpeechSynthesizerObserverInterface::Spee
 void SpeechSynthesizer::resetCurrentInfo(std::shared_ptr<SpeakDirectiveInfo> speakInfo) {
     if (m_currentInfo != speakInfo) {
         if (m_currentInfo) {
-            removeSpeakDirectiveInfo(m_currentInfo->directive->getMessageId());
-            removeDirective(m_currentInfo->directive->getMessageId());
-            m_currentInfo->clear();
+            auto info = m_currentInfo;
+            if (info) {
+                if (info->directive) {
+                    removeSpeakDirectiveInfo(info->directive->getMessageId());
+                    removeDirective(info->directive->getMessageId());
+                }
+                info->clear();
+            }
         }
         m_currentInfo = speakInfo;
     }
diff --git a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
index 21f7e69..25a03f3 100644
--- a/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
+++ b/CapabilityAgents/SpeechSynthesizer/test/SpeechSynthesizerTest.cpp
@@ -903,6 +903,143 @@ TEST_F(SpeechSynthesizerTest, testTimer_notCallStopTwice) {
     ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
 }
 
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnFocusChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
+TEST_F(SpeechSynthesizerTest, testCallingCancelBeforeOnExecuteStateChanged) {
+    auto avsMessageHeader = std::make_shared<AVSMessageHeader>(
+        NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST, DIALOG_REQUEST_ID_TEST);
+    std::shared_ptr<AVSDirective> directive =
+        AVSDirective::create("", avsMessageHeader, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST);
+
+    auto avsMessageHeader2 =
+        std::make_shared<AVSMessageHeader>(NAMESPACE_SPEECH_SYNTHESIZER, NAME_SPEAK, MESSAGE_ID_TEST_2);
+    std::shared_ptr<AVSDirective> directive2 =
+        AVSDirective::create("", avsMessageHeader2, PAYLOAD_TEST, m_attachmentManager, CONTEXT_ID_TEST_2);
+
+    EXPECT_CALL(*(m_mockFocusManager.get()), acquireChannel(CHANNEL_NAME, _, NAMESPACE_SPEECH_SYNTHESIZER))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnAcquireChannel));
+    EXPECT_CALL(*(m_mockDirHandlerResult.get()), setFailed(_))
+        .Times(1)
+        .WillOnce(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetFailed));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, PLAYING_STATE_TEST, StateRefreshPolicy::ALWAYS, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+
+    EXPECT_CALL(
+        *(m_mockContextManager.get()),
+        setState(NAMESPACE_AND_NAME_SPEECH_STATE, FINISHED_STATE_TEST, StateRefreshPolicy::NEVER, 0))
+        .Times(AtLeast(1))
+        .WillRepeatedly(InvokeWithoutArgs(this, &SpeechSynthesizerTest::wakeOnSetState));
+    EXPECT_CALL(
+        *(m_mockSpeechPlayer.get()),
+        attachmentSetSource(A<std::shared_ptr<avsCommon::avs::attachment::AttachmentReader>>(), nullptr))
+        .Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), play(_)).Times(AtLeast(1));
+    EXPECT_CALL(*(m_mockSpeechPlayer.get()), getOffset(_))
+        .Times(AtLeast(1))
+        .WillRepeatedly(Return(OFFSET_IN_CHRONO_MILLISECONDS_TEST));
+
+    m_speechSynthesizer->CapabilityAgent::preHandleDirective(directive, std::move(m_mockDirHandlerResult));
+    m_speechSynthesizer->CapabilityAgent::handleDirective(MESSAGE_ID_TEST);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeAcquireChannelPromise = std::promise<void>();
+    m_wakeAcquireChannelFuture = m_wakeAcquireChannelPromise.get_future();
+
+    m_speechSynthesizer->CapabilityAgent::cancelDirective(MESSAGE_ID_TEST);
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetFailedFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetFailedPromise = std::promise<void>();
+    m_wakeSetFailedFuture = m_wakeSetFailedPromise.get_future();
+
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    m_wakeSetStatePromise = std::promise<void>();
+    m_wakeSetStateFuture = m_wakeSetStatePromise.get_future();
+
+    // send second speak directive and make sure it working
+    m_speechSynthesizer->handleDirectiveImmediately(directive2);
+    ASSERT_TRUE(std::future_status::ready == m_wakeAcquireChannelFuture.wait_for(WAIT_TIMEOUT));
+    m_speechSynthesizer->onFocusChanged(FocusState::FOREGROUND);
+    ASSERT_TRUE(std::future_status::ready == m_wakeSetStateFuture.wait_for(WAIT_TIMEOUT));
+    ASSERT_TRUE(m_mockSpeechPlayer->waitUntilPlaybackStarted());
+}
+
 /**
  * Testing executeCancel() completes execution before onFocusChanged() is called.
  *
diff --git a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
index 16dacdd..764e773 100644
--- a/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
+++ b/CapabilityAgents/TemplateRuntime/src/TemplateRuntime.cpp
@@ -39,7 +39,7 @@ static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_TYPE = "AlexaInter
 /// TemplateRuntime interface name
 static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_NAME = "TemplateRuntime";
 /// TemplateRuntime interface version
-static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.1";
+static const std::string TEMPLATERUNTIME_CAPABILITY_INTERFACE_VERSION = "1.2";
 
 /// String to identify log entries originating from this file.
 static const std::string TAG{"TemplateRuntime"};
@@ -86,13 +86,13 @@ static const std::string AUDIO_ITEM_ID_TAG{"audioItemId"};
 static const size_t MAXIMUM_QUEUE_SIZE{100};
 
 /// Default timeout for clearing the RenderTemplate display card when SpeechSynthesizer is in FINISHED state.
-static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{2000};
+static const std::chrono::milliseconds DEFAULT_TTS_FINISHED_TIMEOUT_MS{8000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in FINISHED state.
 static const std::chrono::milliseconds DEFAULT_AUDIO_FINISHED_TIMEOUT_MS{2000};
 
 /// Default timeout for clearing the RenderPlayerInfo display card when AudioPlayer is in STOPPED/PAUSED state.
-static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{60000};
+static const std::chrono::milliseconds DEFAULT_AUDIO_STOPPED_PAUSED_TIMEOUT_MS{1800000};
 
 /**
  * Creates the TemplateRuntime capability configuration.
diff --git a/Captions/Implementation/src/SystemClockDelay.cpp b/Captions/Implementation/src/SystemClockDelay.cpp
index 77e3037..0c3cf4a 100644
--- a/Captions/Implementation/src/SystemClockDelay.cpp
+++ b/Captions/Implementation/src/SystemClockDelay.cpp
@@ -23,7 +23,7 @@ namespace captions {
 
 void SystemClockDelay::delay(std::chrono::milliseconds milliseconds) {
     int64_t zero = 0;
-    auto duration = std::chrono::milliseconds(std::max(zero, milliseconds.count()));
+    auto duration = std::chrono::milliseconds(std::max(zero, (int64_t)milliseconds.count()));
     std::this_thread::sleep_for(duration);
 }
 
diff --git a/CertifiedSender/src/CertifiedSender.cpp b/CertifiedSender/src/CertifiedSender.cpp
index e923707..fc27a61 100644
--- a/CertifiedSender/src/CertifiedSender.cpp
+++ b/CertifiedSender/src/CertifiedSender.cpp
@@ -184,10 +184,10 @@ inline bool shouldRetryTransmission(MessageRequestObserverInterface::Status stat
         case MessageRequestObserverInterface::Status::SUCCESS_ACCEPTED:
         case MessageRequestObserverInterface::Status::SUCCESS_NO_CONTENT:
         case MessageRequestObserverInterface::Status::SERVER_INTERNAL_ERROR_V2:
-        case MessageRequestObserverInterface::Status::CANCELED:
-        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::BAD_REQUEST:
             return false;
+        case MessageRequestObserverInterface::Status::CANCELED:
+        case MessageRequestObserverInterface::Status::SERVER_OTHER_ERROR:
         case MessageRequestObserverInterface::Status::THROTTLED:
         case MessageRequestObserverInterface::Status::PENDING:
         case MessageRequestObserverInterface::Status::NOT_CONNECTED:
@@ -290,6 +290,7 @@ std::future<bool> CertifiedSender::sendJSONMessage(
 }
 
 bool CertifiedSender::executeSendJSONMessage(std::string jsonMessage, const std::string& uriPathExtension) {
+    ACSDK_DEBUG9(LX(__func__).sensitive("jsonMessage", jsonMessage));
     std::unique_lock<std::mutex> lock(m_mutex);
 
     int queueSize = static_cast<int>(m_messagesToSend.size());
diff --git a/Endpoints/include/Endpoints/EndpointAttributeValidation.h b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
index a952183..08fafde 100644
--- a/Endpoints/include/Endpoints/EndpointAttributeValidation.h
+++ b/Endpoints/include/Endpoints/EndpointAttributeValidation.h
@@ -33,6 +33,14 @@ namespace endpoints {
  */
 bool isEndpointIdValid(const avsCommon::sdkInterfaces::endpoints::EndpointIdentifier& identifier);
 
+/**
+ * Returns whether the given endpointResources follows AVS specification.
+ *
+ * @param endpointResources The endpointResources to be validated.
+ * @return @c true if valid; otherwise, return @c false.
+ */
+bool isEndpointResourcesValid(const avsCommon::avs::EndpointResources& endpointResources);
+
 /**
  * Returns whether the given name follows AVS specification.
  *
diff --git a/Endpoints/include/Endpoints/EndpointBuilder.h b/Endpoints/include/Endpoints/EndpointBuilder.h
index 21dabaa..023a75d 100644
--- a/Endpoints/include/Endpoints/EndpointBuilder.h
+++ b/Endpoints/include/Endpoints/EndpointBuilder.h
@@ -85,6 +85,8 @@ public:
     EndpointBuilder& withFriendlyName(const std::string& friendlyName) override;
     EndpointBuilder& withDescription(const std::string& description) override;
     EndpointBuilder& withManufacturerName(const std::string& manufacturerName) override;
+    EndpointBuilder& withEndpointResources(
+            const avsCommon::avs::EndpointResources& endpointResources) override;
     EndpointBuilder& withDisplayCategory(const std::vector<std::string>& displayCategories) override;
     EndpointBuilder& withAdditionalAttributes(
         const std::string& manufacturer,
@@ -197,6 +199,9 @@ private:
     /// Flag used to indicate whether any unrecoverable error was found.
     bool m_invalidConfiguration;
 
+    /// Flag used to indicate whether endpointResources is used.
+    bool m_isEndpointResourcesUsed;
+
     /// The client endpoint id that is used to build the default endpoint and generate derived endpoints.
     const avsCommon::utils::DeviceInfo m_deviceInfo;
 
diff --git a/Endpoints/src/EndpointAttributeValidation.cpp b/Endpoints/src/EndpointAttributeValidation.cpp
index 8cad3a6..a794ff8 100644
--- a/Endpoints/src/EndpointAttributeValidation.cpp
+++ b/Endpoints/src/EndpointAttributeValidation.cpp
@@ -29,6 +29,10 @@ bool isEndpointIdValid(const EndpointIdentifier& identifier) {
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_ENDPOINT_IDENTIFIER_LENGTH);
 }
 
+bool isEndpointResourcesValid(const EndpointResources& endpointResources) {
+    return endpointResources.isValid();
+}
+
 bool isFriendlyNameValid(const std::string& name) {
     auto length = name.length();
     return (length > 0) && (length <= AVSDiscoveryEndpointAttributes::MAX_FRIENDLY_NAME_LENGTH);
diff --git a/Endpoints/src/EndpointBuilder.cpp b/Endpoints/src/EndpointBuilder.cpp
index ad299fa..0537100 100644
--- a/Endpoints/src/EndpointBuilder.cpp
+++ b/Endpoints/src/EndpointBuilder.cpp
@@ -51,8 +51,8 @@ static const std::string TAG("EndpointBuilder");
 /// String used to join attributes in the generation of the derived endpoint id.
 const std::string ENDPOINT_ID_CONCAT = "::";
 
-/// We will limit the suffix length to 10 characters for now to ensure that we don't go over the endpointId length.
-static constexpr size_t MAX_SUFFIX_LENGTH = 10;
+/// We will limit the suffix length to 64 characters for now to ensure that we don't go over the endpointId length.
+static constexpr size_t MAX_SUFFIX_LENGTH = 64;
 
 std::unique_ptr<EndpointBuilder> EndpointBuilder::create(
     const avsCommon::utils::DeviceInfo& deviceInfo,
@@ -83,6 +83,7 @@ EndpointBuilder::EndpointBuilder(
         m_isDefaultEndpoint{false},
         m_hasBeenBuilt{false},
         m_invalidConfiguration{false},
+        m_isEndpointResourcesUsed(false),
         m_deviceInfo{deviceInfo},
         m_registrationManager{endpointRegistrationManager},
         m_contextManager{contextManager},
@@ -139,6 +140,18 @@ bool EndpointBuilder::finishDefaultEndpointConfiguration() {
     return !m_invalidConfiguration;
 }
 
+EndpointBuilder& EndpointBuilder::withEndpointResources(
+        const avsCommon::avs::EndpointResources& endpointResources) {
+    m_isEndpointResourcesUsed = true;
+    if (!isEndpointResourcesValid(endpointResources)){
+        ACSDK_ERROR(LX(__func__).d("reason", "invalidEndpointResources"));
+        m_invalidConfiguration = true;
+        return *this;
+    }
+    m_attributes.endpointResources = endpointResources;
+    return *this;
+}
+
 EndpointBuilder& EndpointBuilder::withFriendlyName(const std::string& friendlyName) {
     if (!isFriendlyNameValid(friendlyName)) {
         ACSDK_ERROR(LX(__func__).d("reason", "invalidFriendlyName"));
@@ -432,7 +445,14 @@ avsCommon::utils::Optional<EndpointBuilder::EndpointIdentifier> EndpointBuilder:
         return endpointId;
     }
 
-    if (!m_isDefaultEndpoint && !isFriendlyNameValid(m_attributes.friendlyName)) {
+    if (!m_isDefaultEndpoint && m_isEndpointResourcesUsed
+                             && !isEndpointResourcesValid(m_attributes.endpointResources)) {
+        ACSDK_ERROR(LX("buildFailed").d("reason", "invalidEndpointResources"));
+        return endpointId;
+    }
+
+    if (!m_isDefaultEndpoint && !m_isEndpointResourcesUsed
+                             && !isFriendlyNameValid(m_attributes.friendlyName)) {
         ACSDK_ERROR(
             LX("buildFailed").d("reason", "friendlyNameInvalid").sensitive("friendlyName", m_attributes.friendlyName));
         return endpointId;
@@ -454,11 +474,6 @@ avsCommon::utils::Optional<EndpointBuilder::EndpointIdentifier> EndpointBuilder:
     for (auto& capabilityBuilder : m_capabilitiesBuilders) {
         auto capability = capabilityBuilder();
         if (!capability.second) {
-            // Default endpoint might have capability configurations without a directive handler.
-            if (!m_isDefaultEndpoint) {
-                ACSDK_ERROR(LX("buildFailed").d("reason", "buildCapabilityFailed"));
-                return endpointId;
-            }
             endpoint->addCapabilityConfiguration(capability.first);
         } else {
             endpoint->addCapability(capability.first, capability.second);
diff --git a/Integration/test/AudioPlayerIntegrationTest.cpp b/Integration/test/AudioPlayerIntegrationTest.cpp
index 3ad3232..1b98ac3 100644
--- a/Integration/test/AudioPlayerIntegrationTest.cpp
+++ b/Integration/test/AudioPlayerIntegrationTest.cpp
@@ -45,6 +45,9 @@
 #include <AVSCommon/Utils/MediaPlayer/PooledMediaPlayerFactory.h>
 #include <AVSCommon/Utils/Logger/LogEntry.h>
 #include <Captions/CaptionManagerInterface.h>
+#include <CertifiedSender/CertifiedSender.h>
+#include <CertifiedSender/SQLiteMessageStorage.h>
+
 #ifdef GSTREAMER_MEDIA_PLAYER
 #include <MediaPlayer/MediaPlayer.h>
 #else
@@ -89,6 +92,7 @@ using namespace capabilityAgents::speechSynthesizer;
 using namespace capabilityAgents::system;
 using namespace settings;
 using namespace settings::test;
+using namespace certifiedSender;
 #ifdef GSTREAMER_MEDIA_PLAYER
 using namespace mediaPlayer;
 #endif
@@ -390,6 +394,15 @@ protected:
         m_contentMediaPlayer = std::make_shared<TestMediaPlayer>();
 #endif
 
+        auto messageStorage =
+            SQLiteMessageStorage::create(avsCommon::utils::configuration::ConfigurationNode::getRoot());
+
+        m_certifiedSender = CertifiedSender::create(
+            m_avsConnectionManager,
+            m_avsConnectionManager->getConnectionManager(),
+            std::move(messageStorage),
+            m_customerDataManager);
+
         std::vector<std::shared_ptr<MediaPlayerInterface>> players = {m_contentMediaPlayer};
         auto mockFactory = mediaPlayer::PooledMediaPlayerFactory::create(players);
 
@@ -401,6 +414,7 @@ protected:
             m_context->getContextManager(),
             m_exceptionEncounteredSender,
             m_playbackRouter,
+            m_certifiedSender,
             m_captionManager);
         ASSERT_NE(nullptr, m_audioPlayer);
         m_directiveSequencer->addDirectiveHandler(m_audioPlayer);
@@ -423,6 +437,9 @@ protected:
         if (m_audioPlayer) {
             m_audioPlayer->shutdown();
         }
+        if (m_certifiedSender) {
+            m_certifiedSender->shutdown();
+        }
         if (m_avsConnectionManager) {
             m_avsConnectionManager->shutdown();
         }
@@ -547,6 +564,7 @@ protected:
     std::unique_ptr<ACLTestContext> m_context;
 
     std::shared_ptr<TestMessageSender> m_avsConnectionManager;
+    std::shared_ptr<CertifiedSender> m_certifiedSender;
     std::shared_ptr<TestExceptionEncounteredSender> m_exceptionEncounteredSender;
     std::shared_ptr<PlaybackController> m_playbackController;
     std::shared_ptr<PlaybackRouter> m_playbackRouter;
@@ -569,6 +587,7 @@ protected:
     std::shared_ptr<MockSetting<WakeWordConfirmationSettingType>> m_mockWakeWordConfirmationSetting;
     std::shared_ptr<MockSetting<SpeechConfirmationSettingType>> m_mockSpeechConfirmationSetting;
     std::shared_ptr<captions::CaptionManagerInterface> m_captionManager;
+    std::shared_ptr<registrationManager::CustomerDataManager> m_customerDataManager;
 
     FocusState m_focusState;
     std::mutex m_mutex;
diff --git a/SampleApp/include/SampleApp/InteractionManager.h b/SampleApp/include/SampleApp/InteractionManager.h
index 522b713..0bb0a33 100644
--- a/SampleApp/include/SampleApp/InteractionManager.h
+++ b/SampleApp/include/SampleApp/InteractionManager.h
@@ -361,7 +361,7 @@ public:
     /**
      * CallStateObserverInterface methods
      */
-    void onCallStateChange(CallState newState) override;
+    void onCallStateChange(CallState newState, const CallDisplayInfo& displayInfo) override;
 
 #ifdef ENABLE_PCC
     /**
diff --git a/SampleApp/src/InteractionManager.cpp b/SampleApp/src/InteractionManager.cpp
index 7005b40..d3c3bd1 100644
--- a/SampleApp/src/InteractionManager.cpp
+++ b/SampleApp/src/InteractionManager.cpp
@@ -410,7 +410,7 @@ void InteractionManager::onDialogUXStateChanged(DialogUXState state) {
     });
 }
 
-void InteractionManager::onCallStateChange(CallState state) {
+void InteractionManager::onCallStateChange(CallState state, const CallDisplayInfo& displayInfo) {
     m_executor.submit([this, state]() {
         if (CallState::CALL_CONNECTED == state) {
             if (!m_micWrapper->isStreaming()) {
-- 
2.25.0

